# ОТСЕЧЕНИЕ ОТРЕЗКА С ПОМОЩЬЮ АЛГОРИТМА РАЗБИЕНИЯ СРЕДНЕЙ ТОЧКОЙ

# Передаваемые параметры:
# cutter = [xl, xr, yl, yu]
# p = [x, y]
# answer = [x1, y1, x2, y2], если хотя бы часть отрезка видима, 0 - иначе

# t - код точки относительно отсекателя- двоичное число с 4 разрядами:
# t1 = 1, если точка лежит левее окна, и 0 в противном случае;
# t2 - правее, t3 - ниже, t4 - выше
# Первым считается крайний правый бит.

# точка видима, если все биты ее кода - нулевые: t == 0
# иначе - невидима

# отрезок является полностью видимым, если видны обе его вершины:
# (t1 == 0) and (t2 == 0)
# отрезок заведомо частично видим, если видна только одна из вершин:
# (t1 == 0 and t2 != 0) or (t1 != 0 and t2 == 0)

# отрезок является тривиально (полностью) невидимым,
# если побитное логическое произведение кодов концов не равно нулю
# (отрезок целиком лежит по одну сторону от отсекателя):
# t1 & t2 != 0
# в противном случае - может быть целиком или частично видимым или даже целиком невидимым

LEFT = 0b0001
RIGHT = 0b0010
LOWER = 0b0100
UPPER = 0b1000


# вычисление кода t точки point относительно отсекателя cutter
def point_code(cutter, point):
    t = 0b0000
    if point[0] < cutter[0]:
        t += LEFT
    if point[0] > cutter[1]:
        t += RIGHT
    if point[1] > cutter[2]:
        t += LOWER
    if point[1] < cutter[3]:
        t += UPPER

    return t


# расстояние между точками p1, p2
def distance(p1, p2):
    dx = p1[0] - p2[0]
    dy = p1[1] - p2[1]
    return (dx ** 2 + dy ** 2) ** 0.5


# средняя точка отрезка [p1, p2]
def midpoint(p1, p2):
    xm = (p1[0] + p2[0]) / 2
    ym = (p1[1] + p2[1]) / 2
    return [xm, ym]


# отсечение отрезка с помощью алгоритма разбиения средней точкой
def midpoint_cut(cutter, p1, p2, eps):
    answer = []

    # вычисление кодов концевых точек t1 и t2
    t1 = point_code(cutter, p1)
    t2 = point_code(cutter, p2)

    # если отрезок полностью видим, то
    # заносим его вершины в результат и заканчиваем обработку
    if not (t1 or t2):
        answer = [p1[0], p1[1], p2[0], p2[1]]
        return answer

    # если отрезок тривиально (полностью) невидим, то
    # заканчиваем обработку без возвращения результата
    if t1 & t2:
        return

    # запоминаем вершину p1
    p_tmp, t_tmp = p1, t1

    # поиск 2 вершин видимой части
    # (каждый раз - наиболее далеко расположенной от вершины p1 еще видимой точки отрезка)
    for _ in range(2):
        # если p2 уже видима,
        # то занесение ее в результат и переход к поиску следующей вершины видимой части
        if not t2:
            answer.extend(p2)
        # иначе - поиск точки пересечения отрезка и отсекателя
        else:
            while distance(p1, p2) > eps:
                # нахождение средней точки и ее кода
                pm = midpoint(p1, p2)
                tm = point_code(cutter, pm)
                # если отрезок [pm, p2] полностью невидим, то "отрезаем" его
                if tm & t2:
                    p2, t2 = pm, tm
                # иначе приближаемся к точке пересечения c другой стороны
                else:
                    p1, t1 = pm, tm

            # если текуший отрезок является полностью невидимым, то
            # и исходный отрезок объявляеся полностью невидимым
            if t1 & t2:
                return

            # занесение точки пересечения в результат
            answer.extend(p2)

        # обмен вершин местами
        p1, t1 = p2, t2
        p2, t2 = p_tmp, t_tmp
        # и переход к поиску второй видимой вершины

    return map(round, answer)
